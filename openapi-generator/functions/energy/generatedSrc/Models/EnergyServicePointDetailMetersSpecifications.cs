/*
 * CDR Energy API
 *
 * Consumer Data Right end points and payloads for the Energy sector
 *
 * The version of the OpenAPI document: 1.15.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Agl.Cdr.Energy.Client.OpenAPIDateConverter;

namespace Agl.Cdr.Energy.Models
{
    /// <summary>
    /// Technical characteristics of the meter
    /// </summary>
    [DataContract(Name = "EnergyServicePointDetail_meters_specifications")]
    public partial class EnergyServicePointDetailMetersSpecifications : IEquatable<EnergyServicePointDetailMetersSpecifications>, IValidatableObject
    {
        /// <summary>
        /// A code to denote the status of the meter. Note the details of enumeration values below: &lt;ul&gt;&lt;li&gt;**CURRENT** -Applies when a meter is current and not disconnected&lt;/li&gt;&lt;li&gt;**DISCONNECTED** - Applies when a meter is present but has been remotely disconnected&lt;/li&gt;&lt;/ul&gt;
        /// </summary>
        /// <value>A code to denote the status of the meter. Note the details of enumeration values below: &lt;ul&gt;&lt;li&gt;**CURRENT** -Applies when a meter is current and not disconnected&lt;/li&gt;&lt;li&gt;**DISCONNECTED** - Applies when a meter is present but has been remotely disconnected&lt;/li&gt;&lt;/ul&gt;</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum StatusEnum
        {
            /// <summary>
            /// Enum CURRENT for value: CURRENT
            /// </summary>
            [EnumMember(Value = "CURRENT")]
            CURRENT = 1,

            /// <summary>
            /// Enum DISCONNECTED for value: DISCONNECTED
            /// </summary>
            [EnumMember(Value = "DISCONNECTED")]
            DISCONNECTED = 2

        }


        /// <summary>
        /// A code to denote the status of the meter. Note the details of enumeration values below: &lt;ul&gt;&lt;li&gt;**CURRENT** -Applies when a meter is current and not disconnected&lt;/li&gt;&lt;li&gt;**DISCONNECTED** - Applies when a meter is present but has been remotely disconnected&lt;/li&gt;&lt;/ul&gt;
        /// </summary>
        /// <value>A code to denote the status of the meter. Note the details of enumeration values below: &lt;ul&gt;&lt;li&gt;**CURRENT** -Applies when a meter is current and not disconnected&lt;/li&gt;&lt;li&gt;**DISCONNECTED** - Applies when a meter is present but has been remotely disconnected&lt;/li&gt;&lt;/ul&gt;</value>
        [DataMember(Name = "status", IsRequired = true, EmitDefaultValue = false)]
        public StatusEnum Status { get; set; }
        /// <summary>
        /// The metering Installation type code indicates whether the metering installation has to be manually read. Note the details of enumeration values below: &lt;ul&gt;&lt;li&gt;**BASIC** - Accumulation Meter – Type 6&lt;/li&gt;&lt;li&gt;**COMMS1** - Interval Meter with communications – Type 1&lt;/li&gt;&lt;li&gt;**COMMS2** - Interval Meter with communications – Type 2&lt;/li&gt;&lt;li&gt;**COMMS3** - Interval Meter with communications – Type 3&lt;/li&gt;&lt;li&gt;**COMMS4** - Interval Meter with communications – Type 4&lt;/li&gt;&lt;li&gt;**COMMS4C** - CT connected metering installation that meets the minimum services specifications&lt;/li&gt;&lt;li&gt;**COMMS4D** - Whole current metering installation that meets the minimum services specifications&lt;/li&gt;&lt;li&gt;**MRAM** - Small customer metering installation – Type 4A&lt;/li&gt;&lt;li&gt;**MRIM** - Manually Read Interval Meter – Type 5&lt;/li&gt;&lt;li&gt;**UMCP** - Unmetered Supply – Type 7&lt;/li&gt;&lt;li&gt;**VICAMI** - A relevant metering installation as defined in clause 9.9C of the NER&lt;/li&gt;&lt;li&gt;**NCONUML** - Non-contestable unmeter load - Introduced as part of Global Settlement&lt;/li&gt;&lt;/ul&gt;
        /// </summary>
        /// <value>The metering Installation type code indicates whether the metering installation has to be manually read. Note the details of enumeration values below: &lt;ul&gt;&lt;li&gt;**BASIC** - Accumulation Meter – Type 6&lt;/li&gt;&lt;li&gt;**COMMS1** - Interval Meter with communications – Type 1&lt;/li&gt;&lt;li&gt;**COMMS2** - Interval Meter with communications – Type 2&lt;/li&gt;&lt;li&gt;**COMMS3** - Interval Meter with communications – Type 3&lt;/li&gt;&lt;li&gt;**COMMS4** - Interval Meter with communications – Type 4&lt;/li&gt;&lt;li&gt;**COMMS4C** - CT connected metering installation that meets the minimum services specifications&lt;/li&gt;&lt;li&gt;**COMMS4D** - Whole current metering installation that meets the minimum services specifications&lt;/li&gt;&lt;li&gt;**MRAM** - Small customer metering installation – Type 4A&lt;/li&gt;&lt;li&gt;**MRIM** - Manually Read Interval Meter – Type 5&lt;/li&gt;&lt;li&gt;**UMCP** - Unmetered Supply – Type 7&lt;/li&gt;&lt;li&gt;**VICAMI** - A relevant metering installation as defined in clause 9.9C of the NER&lt;/li&gt;&lt;li&gt;**NCONUML** - Non-contestable unmeter load - Introduced as part of Global Settlement&lt;/li&gt;&lt;/ul&gt;</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum InstallationTypeEnum
        {
            /// <summary>
            /// Enum BASIC for value: BASIC
            /// </summary>
            [EnumMember(Value = "BASIC")]
            BASIC = 1,

            /// <summary>
            /// Enum COMMS1 for value: COMMS1
            /// </summary>
            [EnumMember(Value = "COMMS1")]
            COMMS1 = 2,

            /// <summary>
            /// Enum COMMS2 for value: COMMS2
            /// </summary>
            [EnumMember(Value = "COMMS2")]
            COMMS2 = 3,

            /// <summary>
            /// Enum COMMS3 for value: COMMS3
            /// </summary>
            [EnumMember(Value = "COMMS3")]
            COMMS3 = 4,

            /// <summary>
            /// Enum COMMS4 for value: COMMS4
            /// </summary>
            [EnumMember(Value = "COMMS4")]
            COMMS4 = 5,

            /// <summary>
            /// Enum COMMS4C for value: COMMS4C
            /// </summary>
            [EnumMember(Value = "COMMS4C")]
            COMMS4C = 6,

            /// <summary>
            /// Enum COMMS4D for value: COMMS4D
            /// </summary>
            [EnumMember(Value = "COMMS4D")]
            COMMS4D = 7,

            /// <summary>
            /// Enum MRAM for value: MRAM
            /// </summary>
            [EnumMember(Value = "MRAM")]
            MRAM = 8,

            /// <summary>
            /// Enum MRIM for value: MRIM
            /// </summary>
            [EnumMember(Value = "MRIM")]
            MRIM = 9,

            /// <summary>
            /// Enum PROF for value: PROF
            /// </summary>
            [EnumMember(Value = "PROF")]
            PROF = 10,

            /// <summary>
            /// Enum SAMPLE for value: SAMPLE
            /// </summary>
            [EnumMember(Value = "SAMPLE")]
            SAMPLE = 11,

            /// <summary>
            /// Enum UMCP for value: UMCP
            /// </summary>
            [EnumMember(Value = "UMCP")]
            UMCP = 12,

            /// <summary>
            /// Enum VICAMI for value: VICAMI
            /// </summary>
            [EnumMember(Value = "VICAMI")]
            VICAMI = 13,

            /// <summary>
            /// Enum NCOLNUML for value: NCOLNUML
            /// </summary>
            [EnumMember(Value = "NCOLNUML")]
            NCOLNUML = 14

        }


        /// <summary>
        /// The metering Installation type code indicates whether the metering installation has to be manually read. Note the details of enumeration values below: &lt;ul&gt;&lt;li&gt;**BASIC** - Accumulation Meter – Type 6&lt;/li&gt;&lt;li&gt;**COMMS1** - Interval Meter with communications – Type 1&lt;/li&gt;&lt;li&gt;**COMMS2** - Interval Meter with communications – Type 2&lt;/li&gt;&lt;li&gt;**COMMS3** - Interval Meter with communications – Type 3&lt;/li&gt;&lt;li&gt;**COMMS4** - Interval Meter with communications – Type 4&lt;/li&gt;&lt;li&gt;**COMMS4C** - CT connected metering installation that meets the minimum services specifications&lt;/li&gt;&lt;li&gt;**COMMS4D** - Whole current metering installation that meets the minimum services specifications&lt;/li&gt;&lt;li&gt;**MRAM** - Small customer metering installation – Type 4A&lt;/li&gt;&lt;li&gt;**MRIM** - Manually Read Interval Meter – Type 5&lt;/li&gt;&lt;li&gt;**UMCP** - Unmetered Supply – Type 7&lt;/li&gt;&lt;li&gt;**VICAMI** - A relevant metering installation as defined in clause 9.9C of the NER&lt;/li&gt;&lt;li&gt;**NCONUML** - Non-contestable unmeter load - Introduced as part of Global Settlement&lt;/li&gt;&lt;/ul&gt;
        /// </summary>
        /// <value>The metering Installation type code indicates whether the metering installation has to be manually read. Note the details of enumeration values below: &lt;ul&gt;&lt;li&gt;**BASIC** - Accumulation Meter – Type 6&lt;/li&gt;&lt;li&gt;**COMMS1** - Interval Meter with communications – Type 1&lt;/li&gt;&lt;li&gt;**COMMS2** - Interval Meter with communications – Type 2&lt;/li&gt;&lt;li&gt;**COMMS3** - Interval Meter with communications – Type 3&lt;/li&gt;&lt;li&gt;**COMMS4** - Interval Meter with communications – Type 4&lt;/li&gt;&lt;li&gt;**COMMS4C** - CT connected metering installation that meets the minimum services specifications&lt;/li&gt;&lt;li&gt;**COMMS4D** - Whole current metering installation that meets the minimum services specifications&lt;/li&gt;&lt;li&gt;**MRAM** - Small customer metering installation – Type 4A&lt;/li&gt;&lt;li&gt;**MRIM** - Manually Read Interval Meter – Type 5&lt;/li&gt;&lt;li&gt;**UMCP** - Unmetered Supply – Type 7&lt;/li&gt;&lt;li&gt;**VICAMI** - A relevant metering installation as defined in clause 9.9C of the NER&lt;/li&gt;&lt;li&gt;**NCONUML** - Non-contestable unmeter load - Introduced as part of Global Settlement&lt;/li&gt;&lt;/ul&gt;</value>
        [DataMember(Name = "installationType", IsRequired = true, EmitDefaultValue = false)]
        public InstallationTypeEnum InstallationType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="EnergyServicePointDetailMetersSpecifications" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected EnergyServicePointDetailMetersSpecifications() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="EnergyServicePointDetailMetersSpecifications" /> class.
        /// </summary>
        /// <param name="status">A code to denote the status of the meter. Note the details of enumeration values below: &lt;ul&gt;&lt;li&gt;**CURRENT** -Applies when a meter is current and not disconnected&lt;/li&gt;&lt;li&gt;**DISCONNECTED** - Applies when a meter is present but has been remotely disconnected&lt;/li&gt;&lt;/ul&gt; (required).</param>
        /// <param name="installationType">The metering Installation type code indicates whether the metering installation has to be manually read. Note the details of enumeration values below: &lt;ul&gt;&lt;li&gt;**BASIC** - Accumulation Meter – Type 6&lt;/li&gt;&lt;li&gt;**COMMS1** - Interval Meter with communications – Type 1&lt;/li&gt;&lt;li&gt;**COMMS2** - Interval Meter with communications – Type 2&lt;/li&gt;&lt;li&gt;**COMMS3** - Interval Meter with communications – Type 3&lt;/li&gt;&lt;li&gt;**COMMS4** - Interval Meter with communications – Type 4&lt;/li&gt;&lt;li&gt;**COMMS4C** - CT connected metering installation that meets the minimum services specifications&lt;/li&gt;&lt;li&gt;**COMMS4D** - Whole current metering installation that meets the minimum services specifications&lt;/li&gt;&lt;li&gt;**MRAM** - Small customer metering installation – Type 4A&lt;/li&gt;&lt;li&gt;**MRIM** - Manually Read Interval Meter – Type 5&lt;/li&gt;&lt;li&gt;**UMCP** - Unmetered Supply – Type 7&lt;/li&gt;&lt;li&gt;**VICAMI** - A relevant metering installation as defined in clause 9.9C of the NER&lt;/li&gt;&lt;li&gt;**NCONUML** - Non-contestable unmeter load - Introduced as part of Global Settlement&lt;/li&gt;&lt;/ul&gt; (required).</param>
        /// <param name="manufacturer">Free text field to identify the manufacturer of the installed meter.</param>
        /// <param name="model">Free text field to identify the meter manufacturer’s designation for the meter model.</param>
        /// <param name="readType">Code to denote the method and frequency of Meter Reading. The value is formatted as follows: &lt;ul&gt;&lt;li&gt;First Character &#x3D; Remote (R) or Manual (M)&lt;/li&gt;&lt;li&gt;Second Character &#x3D; Mode: T &#x3D; telephone W &#x3D; wireless P &#x3D; powerline I &#x3D; infra-red G &#x3D; galvanic V &#x3D; visual &lt;/li&gt;&lt;li&gt;Third Character &#x3D; Frequency of Scheduled Meter Readings: 1 &#x3D; Twelve times per year 2 &#x3D; Six times per year 3 &#x3D; Four times per year D &#x3D; Daily or weekly&lt;/li&gt;&lt;li&gt;Optional Fourth Character &#x3D; to identify what interval length the meter is capable of reading. This includes five, 15 and 30 minute granularity as the following: A – 5 minute B – 15 minute C – 30 minute D – Cannot convert to 5 minute (i.e. due to metering installation de-energised) M - Manually Read Accumulation Meter&lt;/li&gt;&lt;/ul&gt; For example, &lt;ul&gt;&lt;li&gt;MV3 &#x3D; Manual, Visual, Quarterly&lt;/li&gt; &lt;li&gt;MV3M &#x3D; Manual, Visual, Quarterly, Manually Read Accumulation Meter&lt;/li&gt; &lt;li&gt;RWDC &#x3D; Remote, Wireless, Daily, 30 minutes interval&lt;/li&gt;&lt;/ul&gt;.</param>
        /// <param name="nextScheduledReadDate">This date is the next scheduled meter read date (NSRD) if a manual Meter Reading is required.</param>
        public EnergyServicePointDetailMetersSpecifications(StatusEnum status = default(StatusEnum), InstallationTypeEnum installationType = default(InstallationTypeEnum), string manufacturer = default(string), string model = default(string), string readType = default(string), string nextScheduledReadDate = default(string))
        {
            this.Status = status;
            this.InstallationType = installationType;
            this.Manufacturer = manufacturer;
            this.Model = model;
            this.ReadType = readType;
            this.NextScheduledReadDate = nextScheduledReadDate;
        }

        /// <summary>
        /// Free text field to identify the manufacturer of the installed meter
        /// </summary>
        /// <value>Free text field to identify the manufacturer of the installed meter</value>
        [DataMember(Name = "manufacturer", EmitDefaultValue = false)]
        public string Manufacturer { get; set; }

        /// <summary>
        /// Free text field to identify the meter manufacturer’s designation for the meter model
        /// </summary>
        /// <value>Free text field to identify the meter manufacturer’s designation for the meter model</value>
        [DataMember(Name = "model", EmitDefaultValue = false)]
        public string Model { get; set; }

        /// <summary>
        /// Code to denote the method and frequency of Meter Reading. The value is formatted as follows: &lt;ul&gt;&lt;li&gt;First Character &#x3D; Remote (R) or Manual (M)&lt;/li&gt;&lt;li&gt;Second Character &#x3D; Mode: T &#x3D; telephone W &#x3D; wireless P &#x3D; powerline I &#x3D; infra-red G &#x3D; galvanic V &#x3D; visual &lt;/li&gt;&lt;li&gt;Third Character &#x3D; Frequency of Scheduled Meter Readings: 1 &#x3D; Twelve times per year 2 &#x3D; Six times per year 3 &#x3D; Four times per year D &#x3D; Daily or weekly&lt;/li&gt;&lt;li&gt;Optional Fourth Character &#x3D; to identify what interval length the meter is capable of reading. This includes five, 15 and 30 minute granularity as the following: A – 5 minute B – 15 minute C – 30 minute D – Cannot convert to 5 minute (i.e. due to metering installation de-energised) M - Manually Read Accumulation Meter&lt;/li&gt;&lt;/ul&gt; For example, &lt;ul&gt;&lt;li&gt;MV3 &#x3D; Manual, Visual, Quarterly&lt;/li&gt; &lt;li&gt;MV3M &#x3D; Manual, Visual, Quarterly, Manually Read Accumulation Meter&lt;/li&gt; &lt;li&gt;RWDC &#x3D; Remote, Wireless, Daily, 30 minutes interval&lt;/li&gt;&lt;/ul&gt;
        /// </summary>
        /// <value>Code to denote the method and frequency of Meter Reading. The value is formatted as follows: &lt;ul&gt;&lt;li&gt;First Character &#x3D; Remote (R) or Manual (M)&lt;/li&gt;&lt;li&gt;Second Character &#x3D; Mode: T &#x3D; telephone W &#x3D; wireless P &#x3D; powerline I &#x3D; infra-red G &#x3D; galvanic V &#x3D; visual &lt;/li&gt;&lt;li&gt;Third Character &#x3D; Frequency of Scheduled Meter Readings: 1 &#x3D; Twelve times per year 2 &#x3D; Six times per year 3 &#x3D; Four times per year D &#x3D; Daily or weekly&lt;/li&gt;&lt;li&gt;Optional Fourth Character &#x3D; to identify what interval length the meter is capable of reading. This includes five, 15 and 30 minute granularity as the following: A – 5 minute B – 15 minute C – 30 minute D – Cannot convert to 5 minute (i.e. due to metering installation de-energised) M - Manually Read Accumulation Meter&lt;/li&gt;&lt;/ul&gt; For example, &lt;ul&gt;&lt;li&gt;MV3 &#x3D; Manual, Visual, Quarterly&lt;/li&gt; &lt;li&gt;MV3M &#x3D; Manual, Visual, Quarterly, Manually Read Accumulation Meter&lt;/li&gt; &lt;li&gt;RWDC &#x3D; Remote, Wireless, Daily, 30 minutes interval&lt;/li&gt;&lt;/ul&gt;</value>
        [DataMember(Name = "readType", EmitDefaultValue = false)]
        public string ReadType { get; set; }

        /// <summary>
        /// This date is the next scheduled meter read date (NSRD) if a manual Meter Reading is required
        /// </summary>
        /// <value>This date is the next scheduled meter read date (NSRD) if a manual Meter Reading is required</value>
        [DataMember(Name = "nextScheduledReadDate", EmitDefaultValue = false)]
        public string NextScheduledReadDate { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class EnergyServicePointDetailMetersSpecifications {\n");
            sb.Append("  Status: ").Append(Status).Append("\n");
            sb.Append("  InstallationType: ").Append(InstallationType).Append("\n");
            sb.Append("  Manufacturer: ").Append(Manufacturer).Append("\n");
            sb.Append("  Model: ").Append(Model).Append("\n");
            sb.Append("  ReadType: ").Append(ReadType).Append("\n");
            sb.Append("  NextScheduledReadDate: ").Append(NextScheduledReadDate).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as EnergyServicePointDetailMetersSpecifications);
        }

        /// <summary>
        /// Returns true if EnergyServicePointDetailMetersSpecifications instances are equal
        /// </summary>
        /// <param name="input">Instance of EnergyServicePointDetailMetersSpecifications to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(EnergyServicePointDetailMetersSpecifications input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Status == input.Status ||
                    this.Status.Equals(input.Status)
                ) && 
                (
                    this.InstallationType == input.InstallationType ||
                    this.InstallationType.Equals(input.InstallationType)
                ) && 
                (
                    this.Manufacturer == input.Manufacturer ||
                    (this.Manufacturer != null &&
                    this.Manufacturer.Equals(input.Manufacturer))
                ) && 
                (
                    this.Model == input.Model ||
                    (this.Model != null &&
                    this.Model.Equals(input.Model))
                ) && 
                (
                    this.ReadType == input.ReadType ||
                    (this.ReadType != null &&
                    this.ReadType.Equals(input.ReadType))
                ) && 
                (
                    this.NextScheduledReadDate == input.NextScheduledReadDate ||
                    (this.NextScheduledReadDate != null &&
                    this.NextScheduledReadDate.Equals(input.NextScheduledReadDate))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = hashCode * 59 + this.Status.GetHashCode();
                hashCode = hashCode * 59 + this.InstallationType.GetHashCode();
                if (this.Manufacturer != null)
                    hashCode = hashCode * 59 + this.Manufacturer.GetHashCode();
                if (this.Model != null)
                    hashCode = hashCode * 59 + this.Model.GetHashCode();
                if (this.ReadType != null)
                    hashCode = hashCode * 59 + this.ReadType.GetHashCode();
                if (this.NextScheduledReadDate != null)
                    hashCode = hashCode * 59 + this.NextScheduledReadDate.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
