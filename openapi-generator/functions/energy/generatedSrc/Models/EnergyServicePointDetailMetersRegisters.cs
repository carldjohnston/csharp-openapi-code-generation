/*
 * CDR Energy API
 *
 * Consumer Data Right end points and payloads for the Energy sector
 *
 * The version of the OpenAPI document: 1.15.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Agl.Cdr.Energy.Client.OpenAPIDateConverter;

namespace Agl.Cdr.Energy.Models
{
    /// <summary>
    /// Usage data registers available from the meter
    /// </summary>
    [DataContract(Name = "EnergyServicePointDetail_meters_registers")]
    public partial class EnergyServicePointDetailMetersRegisters : IEquatable<EnergyServicePointDetailMetersRegisters>, IValidatableObject
    {
        /// <summary>
        /// Indicates the consumption type of register
        /// </summary>
        /// <value>Indicates the consumption type of register</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum RegisterConsumptionTypeEnum
        {
            /// <summary>
            /// Enum INTERVAL for value: INTERVAL
            /// </summary>
            [EnumMember(Value = "INTERVAL")]
            INTERVAL = 1,

            /// <summary>
            /// Enum BASIC for value: BASIC
            /// </summary>
            [EnumMember(Value = "BASIC")]
            BASIC = 2,

            /// <summary>
            /// Enum PROFILEDATA for value: PROFILE_DATA
            /// </summary>
            [EnumMember(Value = "PROFILE_DATA")]
            PROFILEDATA = 3,

            /// <summary>
            /// Enum ACTIVEIMPORT for value: ACTIVE_IMPORT
            /// </summary>
            [EnumMember(Value = "ACTIVE_IMPORT")]
            ACTIVEIMPORT = 4,

            /// <summary>
            /// Enum ACTIVE for value: ACTIVE
            /// </summary>
            [EnumMember(Value = "ACTIVE")]
            ACTIVE = 5,

            /// <summary>
            /// Enum REACTIVEIMPORT for value: REACTIVE_IMPORT
            /// </summary>
            [EnumMember(Value = "REACTIVE_IMPORT")]
            REACTIVEIMPORT = 6,

            /// <summary>
            /// Enum REACTIVE for value: REACTIVE
            /// </summary>
            [EnumMember(Value = "REACTIVE")]
            REACTIVE = 7

        }


        /// <summary>
        /// Indicates the consumption type of register
        /// </summary>
        /// <value>Indicates the consumption type of register</value>
        [DataMember(Name = "registerConsumptionType", IsRequired = true, EmitDefaultValue = false)]
        public RegisterConsumptionTypeEnum RegisterConsumptionType { get; set; }
        /// <summary>
        /// Code to identify the time validity of register contents
        /// </summary>
        /// <value>Code to identify the time validity of register contents</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum TimeOfDayEnum
        {
            /// <summary>
            /// Enum ALLDAY for value: ALLDAY
            /// </summary>
            [EnumMember(Value = "ALLDAY")]
            ALLDAY = 1,

            /// <summary>
            /// Enum INTERVAL for value: INTERVAL
            /// </summary>
            [EnumMember(Value = "INTERVAL")]
            INTERVAL = 2,

            /// <summary>
            /// Enum PEAK for value: PEAK
            /// </summary>
            [EnumMember(Value = "PEAK")]
            PEAK = 3,

            /// <summary>
            /// Enum BUSINESS for value: BUSINESS
            /// </summary>
            [EnumMember(Value = "BUSINESS")]
            BUSINESS = 4,

            /// <summary>
            /// Enum SHOULDER for value: SHOULDER
            /// </summary>
            [EnumMember(Value = "SHOULDER")]
            SHOULDER = 5,

            /// <summary>
            /// Enum EVENING for value: EVENING
            /// </summary>
            [EnumMember(Value = "EVENING")]
            EVENING = 6,

            /// <summary>
            /// Enum OFFPEAK for value: OFFPEAK
            /// </summary>
            [EnumMember(Value = "OFFPEAK")]
            OFFPEAK = 7,

            /// <summary>
            /// Enum CONTROLLED for value: CONTROLLED
            /// </summary>
            [EnumMember(Value = "CONTROLLED")]
            CONTROLLED = 8,

            /// <summary>
            /// Enum DEMAND for value: DEMAND
            /// </summary>
            [EnumMember(Value = "DEMAND")]
            DEMAND = 9

        }


        /// <summary>
        /// Code to identify the time validity of register contents
        /// </summary>
        /// <value>Code to identify the time validity of register contents</value>
        [DataMember(Name = "timeOfDay", EmitDefaultValue = false)]
        public TimeOfDayEnum? TimeOfDay { get; set; }
        /// <summary>
        /// Actual/Subtractive Indicator. Note the details of enumeration values below: &lt;ul&gt;&lt;li&gt;**ACTUAL** implies volume of energy actually metered between two dates&lt;/li&gt;&lt;li&gt;**CUMULATIVE** indicates a meter reading for a specific date. A second Meter Reading is required to determine the consumption between those two Meter Reading dates&lt;/li&gt;&lt;/ul&gt;
        /// </summary>
        /// <value>Actual/Subtractive Indicator. Note the details of enumeration values below: &lt;ul&gt;&lt;li&gt;**ACTUAL** implies volume of energy actually metered between two dates&lt;/li&gt;&lt;li&gt;**CUMULATIVE** indicates a meter reading for a specific date. A second Meter Reading is required to determine the consumption between those two Meter Reading dates&lt;/li&gt;&lt;/ul&gt;</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum ConsumptionTypeEnum
        {
            /// <summary>
            /// Enum ACTUAL for value: ACTUAL
            /// </summary>
            [EnumMember(Value = "ACTUAL")]
            ACTUAL = 1,

            /// <summary>
            /// Enum CUMULATIVE for value: CUMULATIVE
            /// </summary>
            [EnumMember(Value = "CUMULATIVE")]
            CUMULATIVE = 2

        }


        /// <summary>
        /// Actual/Subtractive Indicator. Note the details of enumeration values below: &lt;ul&gt;&lt;li&gt;**ACTUAL** implies volume of energy actually metered between two dates&lt;/li&gt;&lt;li&gt;**CUMULATIVE** indicates a meter reading for a specific date. A second Meter Reading is required to determine the consumption between those two Meter Reading dates&lt;/li&gt;&lt;/ul&gt;
        /// </summary>
        /// <value>Actual/Subtractive Indicator. Note the details of enumeration values below: &lt;ul&gt;&lt;li&gt;**ACTUAL** implies volume of energy actually metered between two dates&lt;/li&gt;&lt;li&gt;**CUMULATIVE** indicates a meter reading for a specific date. A second Meter Reading is required to determine the consumption between those two Meter Reading dates&lt;/li&gt;&lt;/ul&gt;</value>
        [DataMember(Name = "consumptionType", EmitDefaultValue = false)]
        public ConsumptionTypeEnum? ConsumptionType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="EnergyServicePointDetailMetersRegisters" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected EnergyServicePointDetailMetersRegisters() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="EnergyServicePointDetailMetersRegisters" /> class.
        /// </summary>
        /// <param name="registerId">Unique identifier of the register within this service point.  Is not globally unique (required).</param>
        /// <param name="registerSuffix">Register suffix of the meter register where the meter reads are obtained (required).</param>
        /// <param name="averagedDailyLoad">The energy delivered through a connection point or metering point over an extended period normalised to a &#39;per day&#39; basis (kWh). This value is calculated annually..</param>
        /// <param name="registerConsumptionType">Indicates the consumption type of register (required).</param>
        /// <param name="networkTariffCode">The Network Tariff Code is a free text field containing a code supplied and published by the local network service provider.</param>
        /// <param name="unitOfMeasure">The unit of measure for data held in this register.</param>
        /// <param name="timeOfDay">Code to identify the time validity of register contents.</param>
        /// <param name="multiplier">Multiplier required to take a register value and turn it into a value representing billable energy.</param>
        /// <param name="controlledLoad">Indicates whether the energy recorded by this register is created under a Controlled Load regime. ControlledLoad field will have &#39;No&#39; if register does not relate to a Controlled Load.  If the register relates to a Controlled Load, it should contain a description of the Controlled Load regime. ControlledLoad field will have &#39;No&#39; if register does not relate to a Controlled Load, “Yes” if register relates to a Controlled Load If absent the status is unknown. .</param>
        /// <param name="consumptionType">Actual/Subtractive Indicator. Note the details of enumeration values below: &lt;ul&gt;&lt;li&gt;**ACTUAL** implies volume of energy actually metered between two dates&lt;/li&gt;&lt;li&gt;**CUMULATIVE** indicates a meter reading for a specific date. A second Meter Reading is required to determine the consumption between those two Meter Reading dates&lt;/li&gt;&lt;/ul&gt;.</param>
        public EnergyServicePointDetailMetersRegisters(string registerId = default(string), string registerSuffix = default(string), decimal averagedDailyLoad = default(decimal), RegisterConsumptionTypeEnum registerConsumptionType = default(RegisterConsumptionTypeEnum), string networkTariffCode = default(string), string unitOfMeasure = default(string), TimeOfDayEnum? timeOfDay = default(TimeOfDayEnum?), decimal multiplier = default(decimal), bool controlledLoad = default(bool), ConsumptionTypeEnum? consumptionType = default(ConsumptionTypeEnum?))
        {
            // to ensure "registerId" is required (not null)
            this.RegisterId = registerId ?? throw new ArgumentNullException("registerId is a required property for EnergyServicePointDetailMetersRegisters and cannot be null");
            // to ensure "registerSuffix" is required (not null)
            this.RegisterSuffix = registerSuffix ?? throw new ArgumentNullException("registerSuffix is a required property for EnergyServicePointDetailMetersRegisters and cannot be null");
            this.RegisterConsumptionType = registerConsumptionType;
            this.AveragedDailyLoad = averagedDailyLoad;
            this.NetworkTariffCode = networkTariffCode;
            this.UnitOfMeasure = unitOfMeasure;
            this.TimeOfDay = timeOfDay;
            this.Multiplier = multiplier;
            this.ControlledLoad = controlledLoad;
            this.ConsumptionType = consumptionType;
        }

        /// <summary>
        /// Unique identifier of the register within this service point.  Is not globally unique
        /// </summary>
        /// <value>Unique identifier of the register within this service point.  Is not globally unique</value>
        [DataMember(Name = "registerId", IsRequired = true, EmitDefaultValue = false)]
        public string RegisterId { get; set; }

        /// <summary>
        /// Register suffix of the meter register where the meter reads are obtained
        /// </summary>
        /// <value>Register suffix of the meter register where the meter reads are obtained</value>
        [DataMember(Name = "registerSuffix", IsRequired = true, EmitDefaultValue = false)]
        public string RegisterSuffix { get; set; }

        /// <summary>
        /// The energy delivered through a connection point or metering point over an extended period normalised to a &#39;per day&#39; basis (kWh). This value is calculated annually.
        /// </summary>
        /// <value>The energy delivered through a connection point or metering point over an extended period normalised to a &#39;per day&#39; basis (kWh). This value is calculated annually.</value>
        [DataMember(Name = "averagedDailyLoad", EmitDefaultValue = false)]
        public decimal AveragedDailyLoad { get; set; }

        /// <summary>
        /// The Network Tariff Code is a free text field containing a code supplied and published by the local network service provider
        /// </summary>
        /// <value>The Network Tariff Code is a free text field containing a code supplied and published by the local network service provider</value>
        [DataMember(Name = "networkTariffCode", EmitDefaultValue = false)]
        public string NetworkTariffCode { get; set; }

        /// <summary>
        /// The unit of measure for data held in this register
        /// </summary>
        /// <value>The unit of measure for data held in this register</value>
        [DataMember(Name = "unitOfMeasure", EmitDefaultValue = false)]
        public string UnitOfMeasure { get; set; }

        /// <summary>
        /// Multiplier required to take a register value and turn it into a value representing billable energy
        /// </summary>
        /// <value>Multiplier required to take a register value and turn it into a value representing billable energy</value>
        [DataMember(Name = "multiplier", EmitDefaultValue = false)]
        public decimal Multiplier { get; set; }

        /// <summary>
        /// Indicates whether the energy recorded by this register is created under a Controlled Load regime. ControlledLoad field will have &#39;No&#39; if register does not relate to a Controlled Load.  If the register relates to a Controlled Load, it should contain a description of the Controlled Load regime. ControlledLoad field will have &#39;No&#39; if register does not relate to a Controlled Load, “Yes” if register relates to a Controlled Load If absent the status is unknown. 
        /// </summary>
        /// <value>Indicates whether the energy recorded by this register is created under a Controlled Load regime. ControlledLoad field will have &#39;No&#39; if register does not relate to a Controlled Load.  If the register relates to a Controlled Load, it should contain a description of the Controlled Load regime. ControlledLoad field will have &#39;No&#39; if register does not relate to a Controlled Load, “Yes” if register relates to a Controlled Load If absent the status is unknown. </value>
        [DataMember(Name = "controlledLoad", EmitDefaultValue = true)]
        public bool ControlledLoad { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class EnergyServicePointDetailMetersRegisters {\n");
            sb.Append("  RegisterId: ").Append(RegisterId).Append("\n");
            sb.Append("  RegisterSuffix: ").Append(RegisterSuffix).Append("\n");
            sb.Append("  AveragedDailyLoad: ").Append(AveragedDailyLoad).Append("\n");
            sb.Append("  RegisterConsumptionType: ").Append(RegisterConsumptionType).Append("\n");
            sb.Append("  NetworkTariffCode: ").Append(NetworkTariffCode).Append("\n");
            sb.Append("  UnitOfMeasure: ").Append(UnitOfMeasure).Append("\n");
            sb.Append("  TimeOfDay: ").Append(TimeOfDay).Append("\n");
            sb.Append("  Multiplier: ").Append(Multiplier).Append("\n");
            sb.Append("  ControlledLoad: ").Append(ControlledLoad).Append("\n");
            sb.Append("  ConsumptionType: ").Append(ConsumptionType).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as EnergyServicePointDetailMetersRegisters);
        }

        /// <summary>
        /// Returns true if EnergyServicePointDetailMetersRegisters instances are equal
        /// </summary>
        /// <param name="input">Instance of EnergyServicePointDetailMetersRegisters to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(EnergyServicePointDetailMetersRegisters input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.RegisterId == input.RegisterId ||
                    (this.RegisterId != null &&
                    this.RegisterId.Equals(input.RegisterId))
                ) && 
                (
                    this.RegisterSuffix == input.RegisterSuffix ||
                    (this.RegisterSuffix != null &&
                    this.RegisterSuffix.Equals(input.RegisterSuffix))
                ) && 
                (
                    this.AveragedDailyLoad == input.AveragedDailyLoad ||
                    this.AveragedDailyLoad.Equals(input.AveragedDailyLoad)
                ) && 
                (
                    this.RegisterConsumptionType == input.RegisterConsumptionType ||
                    this.RegisterConsumptionType.Equals(input.RegisterConsumptionType)
                ) && 
                (
                    this.NetworkTariffCode == input.NetworkTariffCode ||
                    (this.NetworkTariffCode != null &&
                    this.NetworkTariffCode.Equals(input.NetworkTariffCode))
                ) && 
                (
                    this.UnitOfMeasure == input.UnitOfMeasure ||
                    (this.UnitOfMeasure != null &&
                    this.UnitOfMeasure.Equals(input.UnitOfMeasure))
                ) && 
                (
                    this.TimeOfDay == input.TimeOfDay ||
                    this.TimeOfDay.Equals(input.TimeOfDay)
                ) && 
                (
                    this.Multiplier == input.Multiplier ||
                    this.Multiplier.Equals(input.Multiplier)
                ) && 
                (
                    this.ControlledLoad == input.ControlledLoad ||
                    this.ControlledLoad.Equals(input.ControlledLoad)
                ) && 
                (
                    this.ConsumptionType == input.ConsumptionType ||
                    this.ConsumptionType.Equals(input.ConsumptionType)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.RegisterId != null)
                    hashCode = hashCode * 59 + this.RegisterId.GetHashCode();
                if (this.RegisterSuffix != null)
                    hashCode = hashCode * 59 + this.RegisterSuffix.GetHashCode();
                hashCode = hashCode * 59 + this.AveragedDailyLoad.GetHashCode();
                hashCode = hashCode * 59 + this.RegisterConsumptionType.GetHashCode();
                if (this.NetworkTariffCode != null)
                    hashCode = hashCode * 59 + this.NetworkTariffCode.GetHashCode();
                if (this.UnitOfMeasure != null)
                    hashCode = hashCode * 59 + this.UnitOfMeasure.GetHashCode();
                hashCode = hashCode * 59 + this.TimeOfDay.GetHashCode();
                hashCode = hashCode * 59 + this.Multiplier.GetHashCode();
                hashCode = hashCode * 59 + this.ControlledLoad.GetHashCode();
                hashCode = hashCode * 59 + this.ConsumptionType.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
