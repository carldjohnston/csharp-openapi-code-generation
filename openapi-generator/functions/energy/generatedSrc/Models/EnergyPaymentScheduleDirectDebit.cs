/*
 * CDR Energy API
 *
 * Consumer Data Right end points and payloads for the Energy sector
 *
 * The version of the OpenAPI document: 1.15.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Agl.Cdr.Energy.Client.OpenAPIDateConverter;

namespace Agl.Cdr.Energy.Models
{
    /// <summary>
    /// Represents a regular direct debit from a specified bank account. Mandatory if paymentScheduleUType is set to directDebit
    /// </summary>
    [DataContract(Name = "EnergyPaymentSchedule_directDebit")]
    public partial class EnergyPaymentScheduleDirectDebit : IEquatable<EnergyPaymentScheduleDirectDebit>, IValidatableObject
    {
        /// <summary>
        /// The mechanism by which the payment amount is calculated.  Explanation of values are as follows:&lt;br/&gt;&lt;ul&gt;&lt;li&gt;**STATIC** - Indicates a consistent, static amount, per payment&lt;/li&gt;&lt;li&gt;**BALANCE** - Indicates that the outstanding balance for the account is paid per period&lt;/li&gt;&lt;li&gt;**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm&lt;/li&gt;&lt;/ul&gt;
        /// </summary>
        /// <value>The mechanism by which the payment amount is calculated.  Explanation of values are as follows:&lt;br/&gt;&lt;ul&gt;&lt;li&gt;**STATIC** - Indicates a consistent, static amount, per payment&lt;/li&gt;&lt;li&gt;**BALANCE** - Indicates that the outstanding balance for the account is paid per period&lt;/li&gt;&lt;li&gt;**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm&lt;/li&gt;&lt;/ul&gt;</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum CalculationTypeEnum
        {
            /// <summary>
            /// Enum STATIC for value: STATIC
            /// </summary>
            [EnumMember(Value = "STATIC")]
            STATIC = 1,

            /// <summary>
            /// Enum BALANCE for value: BALANCE
            /// </summary>
            [EnumMember(Value = "BALANCE")]
            BALANCE = 2,

            /// <summary>
            /// Enum CALCULATED for value: CALCULATED
            /// </summary>
            [EnumMember(Value = "CALCULATED")]
            CALCULATED = 3

        }


        /// <summary>
        /// The mechanism by which the payment amount is calculated.  Explanation of values are as follows:&lt;br/&gt;&lt;ul&gt;&lt;li&gt;**STATIC** - Indicates a consistent, static amount, per payment&lt;/li&gt;&lt;li&gt;**BALANCE** - Indicates that the outstanding balance for the account is paid per period&lt;/li&gt;&lt;li&gt;**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm&lt;/li&gt;&lt;/ul&gt;
        /// </summary>
        /// <value>The mechanism by which the payment amount is calculated.  Explanation of values are as follows:&lt;br/&gt;&lt;ul&gt;&lt;li&gt;**STATIC** - Indicates a consistent, static amount, per payment&lt;/li&gt;&lt;li&gt;**BALANCE** - Indicates that the outstanding balance for the account is paid per period&lt;/li&gt;&lt;li&gt;**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm&lt;/li&gt;&lt;/ul&gt;</value>
        [DataMember(Name = "calculationType", IsRequired = true, EmitDefaultValue = false)]
        public CalculationTypeEnum CalculationType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="EnergyPaymentScheduleDirectDebit" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected EnergyPaymentScheduleDirectDebit() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="EnergyPaymentScheduleDirectDebit" /> class.
        /// </summary>
        /// <param name="isTokenised">Flag indicating that the account details are tokenised and cannot be shared.  False if absent.  If false then bsb and accountNumber should not be expected to be included.</param>
        /// <param name="bsb">The unmasked BSB for the account to be debited. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces.  Is required if isTokenised is absent or false.</param>
        /// <param name="accountNumber">The unmasked account number for the account to be debited. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces.  Is required if isTokenised is absent or false.</param>
        /// <param name="paymentFrequency">The frequency that payments will occur.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax) (required).</param>
        /// <param name="calculationType">The mechanism by which the payment amount is calculated.  Explanation of values are as follows:&lt;br/&gt;&lt;ul&gt;&lt;li&gt;**STATIC** - Indicates a consistent, static amount, per payment&lt;/li&gt;&lt;li&gt;**BALANCE** - Indicates that the outstanding balance for the account is paid per period&lt;/li&gt;&lt;li&gt;**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm&lt;/li&gt;&lt;/ul&gt; (required).</param>
        public EnergyPaymentScheduleDirectDebit(string isTokenised = default(string), string bsb = default(string), string accountNumber = default(string), string paymentFrequency = default(string), CalculationTypeEnum calculationType = default(CalculationTypeEnum))
        {
            // to ensure "paymentFrequency" is required (not null)
            this.PaymentFrequency = paymentFrequency ?? throw new ArgumentNullException("paymentFrequency is a required property for EnergyPaymentScheduleDirectDebit and cannot be null");
            this.CalculationType = calculationType;
            this.IsTokenised = isTokenised;
            this.Bsb = bsb;
            this.AccountNumber = accountNumber;
        }

        /// <summary>
        /// Flag indicating that the account details are tokenised and cannot be shared.  False if absent.  If false then bsb and accountNumber should not be expected to be included
        /// </summary>
        /// <value>Flag indicating that the account details are tokenised and cannot be shared.  False if absent.  If false then bsb and accountNumber should not be expected to be included</value>
        [DataMember(Name = "isTokenised", EmitDefaultValue = false)]
        public string IsTokenised { get; set; }

        /// <summary>
        /// The unmasked BSB for the account to be debited. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces.  Is required if isTokenised is absent or false
        /// </summary>
        /// <value>The unmasked BSB for the account to be debited. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces.  Is required if isTokenised is absent or false</value>
        [DataMember(Name = "bsb", EmitDefaultValue = false)]
        public string Bsb { get; set; }

        /// <summary>
        /// The unmasked account number for the account to be debited. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces.  Is required if isTokenised is absent or false
        /// </summary>
        /// <value>The unmasked account number for the account to be debited. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces.  Is required if isTokenised is absent or false</value>
        [DataMember(Name = "accountNumber", EmitDefaultValue = false)]
        public string AccountNumber { get; set; }

        /// <summary>
        /// The frequency that payments will occur.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
        /// </summary>
        /// <value>The frequency that payments will occur.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)</value>
        [DataMember(Name = "paymentFrequency", IsRequired = true, EmitDefaultValue = false)]
        public string PaymentFrequency { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class EnergyPaymentScheduleDirectDebit {\n");
            sb.Append("  IsTokenised: ").Append(IsTokenised).Append("\n");
            sb.Append("  Bsb: ").Append(Bsb).Append("\n");
            sb.Append("  AccountNumber: ").Append(AccountNumber).Append("\n");
            sb.Append("  PaymentFrequency: ").Append(PaymentFrequency).Append("\n");
            sb.Append("  CalculationType: ").Append(CalculationType).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as EnergyPaymentScheduleDirectDebit);
        }

        /// <summary>
        /// Returns true if EnergyPaymentScheduleDirectDebit instances are equal
        /// </summary>
        /// <param name="input">Instance of EnergyPaymentScheduleDirectDebit to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(EnergyPaymentScheduleDirectDebit input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.IsTokenised == input.IsTokenised ||
                    (this.IsTokenised != null &&
                    this.IsTokenised.Equals(input.IsTokenised))
                ) && 
                (
                    this.Bsb == input.Bsb ||
                    (this.Bsb != null &&
                    this.Bsb.Equals(input.Bsb))
                ) && 
                (
                    this.AccountNumber == input.AccountNumber ||
                    (this.AccountNumber != null &&
                    this.AccountNumber.Equals(input.AccountNumber))
                ) && 
                (
                    this.PaymentFrequency == input.PaymentFrequency ||
                    (this.PaymentFrequency != null &&
                    this.PaymentFrequency.Equals(input.PaymentFrequency))
                ) && 
                (
                    this.CalculationType == input.CalculationType ||
                    this.CalculationType.Equals(input.CalculationType)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.IsTokenised != null)
                    hashCode = hashCode * 59 + this.IsTokenised.GetHashCode();
                if (this.Bsb != null)
                    hashCode = hashCode * 59 + this.Bsb.GetHashCode();
                if (this.AccountNumber != null)
                    hashCode = hashCode * 59 + this.AccountNumber.GetHashCode();
                if (this.PaymentFrequency != null)
                    hashCode = hashCode * 59 + this.PaymentFrequency.GetHashCode();
                hashCode = hashCode * 59 + this.CalculationType.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
