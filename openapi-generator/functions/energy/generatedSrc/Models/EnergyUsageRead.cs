/*
 * CDR Energy API
 *
 * Consumer Data Right end points and payloads for the Energy sector
 *
 * The version of the OpenAPI document: 1.15.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Agl.Cdr.Energy.Client.OpenAPIDateConverter;

namespace Agl.Cdr.Energy.Models
{
    /// <summary>
    /// EnergyUsageRead
    /// </summary>
    [DataContract(Name = "EnergyUsageRead")]
    public partial class EnergyUsageRead : IEquatable<EnergyUsageRead>, IValidatableObject
    {
        /// <summary>
        /// Specify the type of the meter read data
        /// </summary>
        /// <value>Specify the type of the meter read data</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum ReadUTypeEnum
        {
            /// <summary>
            /// Enum BasicRead for value: basicRead
            /// </summary>
            [EnumMember(Value = "basicRead")]
            BasicRead = 1,

            /// <summary>
            /// Enum IntervalRead for value: intervalRead
            /// </summary>
            [EnumMember(Value = "intervalRead")]
            IntervalRead = 2

        }


        /// <summary>
        /// Specify the type of the meter read data
        /// </summary>
        /// <value>Specify the type of the meter read data</value>
        [DataMember(Name = "readUType", IsRequired = true, EmitDefaultValue = false)]
        public ReadUTypeEnum ReadUType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="EnergyUsageRead" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected EnergyUsageRead() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="EnergyUsageRead" /> class.
        /// </summary>
        /// <param name="servicePointId">Tokenised ID of the service point to be used for referring to the service point in the CDR API suite.  To be created in accordance with CDR ID permanence requirements (required).</param>
        /// <param name="registerId">Register ID of the meter register where the meter reads are obtained.</param>
        /// <param name="registerSuffix">Register suffix of the meter register where the meter reads are obtained (required).</param>
        /// <param name="meterID">Meter id/serial number as it appears in customer’s bill. ID permanence rules do not apply..</param>
        /// <param name="controlledLoad">Indicates whether the energy recorded by this register is created under a Controlled Load regime. ControlledLoad field will have &#39;No if register does not relate to a Controlled Load, “Yes” if register relates to a Controlled Load If absent the status is unknown. .</param>
        /// <param name="readStartDate">Date time when the meter reads start (required).</param>
        /// <param name="readEndDate">Date time when the meter reads end.  If absent then assumed to be equal to readStartDate.  In this case the entry represents data for a single date specified by readStartDate.</param>
        /// <param name="unitOfMeasure">Unit of measure of the meter reads. Refer to Appendix B of &lt;a href&#x3D;&#39;https://www.aemo.com.au/-/media/files/stakeholder_consultation/consultations/nem-consultations/2019/5ms-metering-package-2/final-determination/mdff-specification-nem12-nem13-v21-final-determination-clean.pdf?la&#x3D;en&amp;hash&#x3D;03FCBA0D60E091DE00F2361AE76206EA&#39;&gt;MDFF Specification NEM12 NEM13 v2.1&lt;/a&gt; for a list of possible values.</param>
        /// <param name="readUType">Specify the type of the meter read data (required).</param>
        /// <param name="basicRead">basicRead.</param>
        /// <param name="intervalRead">intervalRead.</param>
        public EnergyUsageRead(string servicePointId = default(string), string registerId = default(string), string registerSuffix = default(string), string meterID = default(string), bool controlledLoad = default(bool), string readStartDate = default(string), string readEndDate = default(string), string unitOfMeasure = default(string), ReadUTypeEnum readUType = default(ReadUTypeEnum), EnergyUsageReadBasicRead basicRead = default(EnergyUsageReadBasicRead), EnergyUsageReadIntervalRead intervalRead = default(EnergyUsageReadIntervalRead))
        {
            // to ensure "servicePointId" is required (not null)
            this.ServicePointId = servicePointId ?? throw new ArgumentNullException("servicePointId is a required property for EnergyUsageRead and cannot be null");
            // to ensure "registerSuffix" is required (not null)
            this.RegisterSuffix = registerSuffix ?? throw new ArgumentNullException("registerSuffix is a required property for EnergyUsageRead and cannot be null");
            // to ensure "readStartDate" is required (not null)
            this.ReadStartDate = readStartDate ?? throw new ArgumentNullException("readStartDate is a required property for EnergyUsageRead and cannot be null");
            this.ReadUType = readUType;
            this.RegisterId = registerId;
            this.MeterID = meterID;
            this.ControlledLoad = controlledLoad;
            this.ReadEndDate = readEndDate;
            this.UnitOfMeasure = unitOfMeasure;
            this.BasicRead = basicRead;
            this.IntervalRead = intervalRead;
        }

        /// <summary>
        /// Tokenised ID of the service point to be used for referring to the service point in the CDR API suite.  To be created in accordance with CDR ID permanence requirements
        /// </summary>
        /// <value>Tokenised ID of the service point to be used for referring to the service point in the CDR API suite.  To be created in accordance with CDR ID permanence requirements</value>
        [DataMember(Name = "servicePointId", IsRequired = true, EmitDefaultValue = false)]
        public string ServicePointId { get; set; }

        /// <summary>
        /// Register ID of the meter register where the meter reads are obtained
        /// </summary>
        /// <value>Register ID of the meter register where the meter reads are obtained</value>
        [DataMember(Name = "registerId", EmitDefaultValue = false)]
        public string RegisterId { get; set; }

        /// <summary>
        /// Register suffix of the meter register where the meter reads are obtained
        /// </summary>
        /// <value>Register suffix of the meter register where the meter reads are obtained</value>
        [DataMember(Name = "registerSuffix", IsRequired = true, EmitDefaultValue = false)]
        public string RegisterSuffix { get; set; }

        /// <summary>
        /// Meter id/serial number as it appears in customer’s bill. ID permanence rules do not apply.
        /// </summary>
        /// <value>Meter id/serial number as it appears in customer’s bill. ID permanence rules do not apply.</value>
        [DataMember(Name = "meterID", EmitDefaultValue = false)]
        public string MeterID { get; set; }

        /// <summary>
        /// Indicates whether the energy recorded by this register is created under a Controlled Load regime. ControlledLoad field will have &#39;No if register does not relate to a Controlled Load, “Yes” if register relates to a Controlled Load If absent the status is unknown. 
        /// </summary>
        /// <value>Indicates whether the energy recorded by this register is created under a Controlled Load regime. ControlledLoad field will have &#39;No if register does not relate to a Controlled Load, “Yes” if register relates to a Controlled Load If absent the status is unknown. </value>
        [DataMember(Name = "controlledLoad", EmitDefaultValue = true)]
        public bool ControlledLoad { get; set; }

        /// <summary>
        /// Date time when the meter reads start
        /// </summary>
        /// <value>Date time when the meter reads start</value>
        [DataMember(Name = "readStartDate", IsRequired = true, EmitDefaultValue = false)]
        public string ReadStartDate { get; set; }

        /// <summary>
        /// Date time when the meter reads end.  If absent then assumed to be equal to readStartDate.  In this case the entry represents data for a single date specified by readStartDate
        /// </summary>
        /// <value>Date time when the meter reads end.  If absent then assumed to be equal to readStartDate.  In this case the entry represents data for a single date specified by readStartDate</value>
        [DataMember(Name = "readEndDate", EmitDefaultValue = false)]
        public string ReadEndDate { get; set; }

        /// <summary>
        /// Unit of measure of the meter reads. Refer to Appendix B of &lt;a href&#x3D;&#39;https://www.aemo.com.au/-/media/files/stakeholder_consultation/consultations/nem-consultations/2019/5ms-metering-package-2/final-determination/mdff-specification-nem12-nem13-v21-final-determination-clean.pdf?la&#x3D;en&amp;hash&#x3D;03FCBA0D60E091DE00F2361AE76206EA&#39;&gt;MDFF Specification NEM12 NEM13 v2.1&lt;/a&gt; for a list of possible values
        /// </summary>
        /// <value>Unit of measure of the meter reads. Refer to Appendix B of &lt;a href&#x3D;&#39;https://www.aemo.com.au/-/media/files/stakeholder_consultation/consultations/nem-consultations/2019/5ms-metering-package-2/final-determination/mdff-specification-nem12-nem13-v21-final-determination-clean.pdf?la&#x3D;en&amp;hash&#x3D;03FCBA0D60E091DE00F2361AE76206EA&#39;&gt;MDFF Specification NEM12 NEM13 v2.1&lt;/a&gt; for a list of possible values</value>
        [DataMember(Name = "unitOfMeasure", EmitDefaultValue = false)]
        public string UnitOfMeasure { get; set; }

        /// <summary>
        /// Gets or Sets BasicRead
        /// </summary>
        [DataMember(Name = "basicRead", EmitDefaultValue = false)]
        public EnergyUsageReadBasicRead BasicRead { get; set; }

        /// <summary>
        /// Gets or Sets IntervalRead
        /// </summary>
        [DataMember(Name = "intervalRead", EmitDefaultValue = false)]
        public EnergyUsageReadIntervalRead IntervalRead { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class EnergyUsageRead {\n");
            sb.Append("  ServicePointId: ").Append(ServicePointId).Append("\n");
            sb.Append("  RegisterId: ").Append(RegisterId).Append("\n");
            sb.Append("  RegisterSuffix: ").Append(RegisterSuffix).Append("\n");
            sb.Append("  MeterID: ").Append(MeterID).Append("\n");
            sb.Append("  ControlledLoad: ").Append(ControlledLoad).Append("\n");
            sb.Append("  ReadStartDate: ").Append(ReadStartDate).Append("\n");
            sb.Append("  ReadEndDate: ").Append(ReadEndDate).Append("\n");
            sb.Append("  UnitOfMeasure: ").Append(UnitOfMeasure).Append("\n");
            sb.Append("  ReadUType: ").Append(ReadUType).Append("\n");
            sb.Append("  BasicRead: ").Append(BasicRead).Append("\n");
            sb.Append("  IntervalRead: ").Append(IntervalRead).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as EnergyUsageRead);
        }

        /// <summary>
        /// Returns true if EnergyUsageRead instances are equal
        /// </summary>
        /// <param name="input">Instance of EnergyUsageRead to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(EnergyUsageRead input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.ServicePointId == input.ServicePointId ||
                    (this.ServicePointId != null &&
                    this.ServicePointId.Equals(input.ServicePointId))
                ) && 
                (
                    this.RegisterId == input.RegisterId ||
                    (this.RegisterId != null &&
                    this.RegisterId.Equals(input.RegisterId))
                ) && 
                (
                    this.RegisterSuffix == input.RegisterSuffix ||
                    (this.RegisterSuffix != null &&
                    this.RegisterSuffix.Equals(input.RegisterSuffix))
                ) && 
                (
                    this.MeterID == input.MeterID ||
                    (this.MeterID != null &&
                    this.MeterID.Equals(input.MeterID))
                ) && 
                (
                    this.ControlledLoad == input.ControlledLoad ||
                    this.ControlledLoad.Equals(input.ControlledLoad)
                ) && 
                (
                    this.ReadStartDate == input.ReadStartDate ||
                    (this.ReadStartDate != null &&
                    this.ReadStartDate.Equals(input.ReadStartDate))
                ) && 
                (
                    this.ReadEndDate == input.ReadEndDate ||
                    (this.ReadEndDate != null &&
                    this.ReadEndDate.Equals(input.ReadEndDate))
                ) && 
                (
                    this.UnitOfMeasure == input.UnitOfMeasure ||
                    (this.UnitOfMeasure != null &&
                    this.UnitOfMeasure.Equals(input.UnitOfMeasure))
                ) && 
                (
                    this.ReadUType == input.ReadUType ||
                    this.ReadUType.Equals(input.ReadUType)
                ) && 
                (
                    this.BasicRead == input.BasicRead ||
                    (this.BasicRead != null &&
                    this.BasicRead.Equals(input.BasicRead))
                ) && 
                (
                    this.IntervalRead == input.IntervalRead ||
                    (this.IntervalRead != null &&
                    this.IntervalRead.Equals(input.IntervalRead))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.ServicePointId != null)
                    hashCode = hashCode * 59 + this.ServicePointId.GetHashCode();
                if (this.RegisterId != null)
                    hashCode = hashCode * 59 + this.RegisterId.GetHashCode();
                if (this.RegisterSuffix != null)
                    hashCode = hashCode * 59 + this.RegisterSuffix.GetHashCode();
                if (this.MeterID != null)
                    hashCode = hashCode * 59 + this.MeterID.GetHashCode();
                hashCode = hashCode * 59 + this.ControlledLoad.GetHashCode();
                if (this.ReadStartDate != null)
                    hashCode = hashCode * 59 + this.ReadStartDate.GetHashCode();
                if (this.ReadEndDate != null)
                    hashCode = hashCode * 59 + this.ReadEndDate.GetHashCode();
                if (this.UnitOfMeasure != null)
                    hashCode = hashCode * 59 + this.UnitOfMeasure.GetHashCode();
                hashCode = hashCode * 59 + this.ReadUType.GetHashCode();
                if (this.BasicRead != null)
                    hashCode = hashCode * 59 + this.BasicRead.GetHashCode();
                if (this.IntervalRead != null)
                    hashCode = hashCode * 59 + this.IntervalRead.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
