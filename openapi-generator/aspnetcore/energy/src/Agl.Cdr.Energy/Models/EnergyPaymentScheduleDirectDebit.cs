/*
 * CDR Energy API
 *
 * Consumer Data Right end points and payloads for the Energy sector
 *
 * The version of the OpenAPI document: 1.15.0
 * 
 * Generated by: https://openapi-generator.tech
 */

using System;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Agl.Cdr.Energy.Converters;

namespace Agl.Cdr.Energy.Models
{ 
    /// <summary>
    /// Represents a regular direct debit from a specified bank account. Mandatory if paymentScheduleUType is set to directDebit
    /// </summary>
    [DataContract]
    public partial class EnergyPaymentScheduleDirectDebit : IEquatable<EnergyPaymentScheduleDirectDebit>
    {
        /// <summary>
        /// Flag indicating that the account details are tokenised and cannot be shared.  False if absent.  If false then bsb and accountNumber should not be expected to be included
        /// </summary>
        /// <value>Flag indicating that the account details are tokenised and cannot be shared.  False if absent.  If false then bsb and accountNumber should not be expected to be included</value>
        [DataMember(Name="isTokenised", EmitDefaultValue=false)]
        public string IsTokenised { get; set; }

        /// <summary>
        /// The unmasked BSB for the account to be debited. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces.  Is required if isTokenised is absent or false
        /// </summary>
        /// <value>The unmasked BSB for the account to be debited. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces.  Is required if isTokenised is absent or false</value>
        [DataMember(Name="bsb", EmitDefaultValue=false)]
        public string Bsb { get; set; }

        /// <summary>
        /// The unmasked account number for the account to be debited. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces.  Is required if isTokenised is absent or false
        /// </summary>
        /// <value>The unmasked account number for the account to be debited. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces.  Is required if isTokenised is absent or false</value>
        [DataMember(Name="accountNumber", EmitDefaultValue=false)]
        public string AccountNumber { get; set; }

        /// <summary>
        /// The frequency that payments will occur.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
        /// </summary>
        /// <value>The frequency that payments will occur.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)</value>
        [Required]
        [DataMember(Name="paymentFrequency", EmitDefaultValue=false)]
        public string PaymentFrequency { get; set; }


        /// <summary>
        /// The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
        /// </summary>
        /// <value>The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul></value>
        [TypeConverter(typeof(CustomEnumConverter<CalculationTypeEnum>))]
        [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public enum CalculationTypeEnum
        {
            
            /// <summary>
            /// Enum STATICEnum for STATIC
            /// </summary>
            [EnumMember(Value = "STATIC")]
            STATICEnum = 1,
            
            /// <summary>
            /// Enum BALANCEEnum for BALANCE
            /// </summary>
            [EnumMember(Value = "BALANCE")]
            BALANCEEnum = 2,
            
            /// <summary>
            /// Enum CALCULATEDEnum for CALCULATED
            /// </summary>
            [EnumMember(Value = "CALCULATED")]
            CALCULATEDEnum = 3
        }

        /// <summary>
        /// The mechanism by which the payment amount is calculated.  Explanation of values are as follows:&lt;br/&gt;&lt;ul&gt;&lt;li&gt;**STATIC** - Indicates a consistent, static amount, per payment&lt;/li&gt;&lt;li&gt;**BALANCE** - Indicates that the outstanding balance for the account is paid per period&lt;/li&gt;&lt;li&gt;**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm&lt;/li&gt;&lt;/ul&gt;
        /// </summary>
        /// <value>The mechanism by which the payment amount is calculated.  Explanation of values are as follows:&lt;br/&gt;&lt;ul&gt;&lt;li&gt;**STATIC** - Indicates a consistent, static amount, per payment&lt;/li&gt;&lt;li&gt;**BALANCE** - Indicates that the outstanding balance for the account is paid per period&lt;/li&gt;&lt;li&gt;**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm&lt;/li&gt;&lt;/ul&gt;</value>
        [Required]
        [DataMember(Name="calculationType", EmitDefaultValue=false)]
        public CalculationTypeEnum CalculationType { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class EnergyPaymentScheduleDirectDebit {\n");
            sb.Append("  IsTokenised: ").Append(IsTokenised).Append("\n");
            sb.Append("  Bsb: ").Append(Bsb).Append("\n");
            sb.Append("  AccountNumber: ").Append(AccountNumber).Append("\n");
            sb.Append("  PaymentFrequency: ").Append(PaymentFrequency).Append("\n");
            sb.Append("  CalculationType: ").Append(CalculationType).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (obj is null) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((EnergyPaymentScheduleDirectDebit)obj);
        }

        /// <summary>
        /// Returns true if EnergyPaymentScheduleDirectDebit instances are equal
        /// </summary>
        /// <param name="other">Instance of EnergyPaymentScheduleDirectDebit to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(EnergyPaymentScheduleDirectDebit other)
        {
            if (other is null) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    IsTokenised == other.IsTokenised ||
                    IsTokenised != null &&
                    IsTokenised.Equals(other.IsTokenised)
                ) && 
                (
                    Bsb == other.Bsb ||
                    Bsb != null &&
                    Bsb.Equals(other.Bsb)
                ) && 
                (
                    AccountNumber == other.AccountNumber ||
                    AccountNumber != null &&
                    AccountNumber.Equals(other.AccountNumber)
                ) && 
                (
                    PaymentFrequency == other.PaymentFrequency ||
                    PaymentFrequency != null &&
                    PaymentFrequency.Equals(other.PaymentFrequency)
                ) && 
                (
                    CalculationType == other.CalculationType ||
                    
                    CalculationType.Equals(other.CalculationType)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (IsTokenised != null)
                    hashCode = hashCode * 59 + IsTokenised.GetHashCode();
                    if (Bsb != null)
                    hashCode = hashCode * 59 + Bsb.GetHashCode();
                    if (AccountNumber != null)
                    hashCode = hashCode * 59 + AccountNumber.GetHashCode();
                    if (PaymentFrequency != null)
                    hashCode = hashCode * 59 + PaymentFrequency.GetHashCode();
                    
                    hashCode = hashCode * 59 + CalculationType.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(EnergyPaymentScheduleDirectDebit left, EnergyPaymentScheduleDirectDebit right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(EnergyPaymentScheduleDirectDebit left, EnergyPaymentScheduleDirectDebit right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
