/*
 * CDR Energy API
 *
 * Consumer Data Right end points and payloads for the Energy sector
 *
 * The version of the OpenAPI document: 1.15.0
 * 
 * Generated by: https://openapi-generator.tech
 */

using System;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Agl.Cdr.Energy.Converters;

namespace Agl.Cdr.Energy.Models
{ 
    /// <summary>
    /// 
    /// </summary>
    [DataContract]
    public partial class EnergyPlanContract : IEquatable<EnergyPlanContract>
    {
        /// <summary>
        /// Free text field containing additional information of the fees for this contract
        /// </summary>
        /// <value>Free text field containing additional information of the fees for this contract</value>
        [DataMember(Name="additionalFeeInformation", EmitDefaultValue=false)]
        public string AdditionalFeeInformation { get; set; }


        /// <summary>
        /// The pricing model for the contract.  Contracts for gas must use SINGLE_RATE.  Note that the detail for the enumeration values are:<ul><li>**SINGLE_RATE** - all energy usage is charged at a single unit rate no matter when it is consumed. Multiple unit rates may exist that correspond to varying volumes of usage i.e. a ‘block’ or ‘step’ tariff (first 50kWh @ X cents, next 50kWh at Y cents etc.</li><li>**SINGLE_RATE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**TIME_OF_USE** - energy usage is charged at unit rates that vary dependent on time of day and day of week that the energy is consumed</li><li>**TIME_OF_USE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**FLEXIBLE** - energy usage is charged at unit rates that vary based on external factors</li><li>**FLEXIBLE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**QUOTA** - all energy usage is charged at a single fixed rate, up to a specified usage quota/allowance. All excess usage beyond the allowance is then charged at a single unit rate (may not be the best way to explain it but it is essentially a ‘subscription’ or telco style product i.e. $50/month for up to 150kWh included usage</li></ul>
        /// </summary>
        /// <value>The pricing model for the contract.  Contracts for gas must use SINGLE_RATE.  Note that the detail for the enumeration values are:<ul><li>**SINGLE_RATE** - all energy usage is charged at a single unit rate no matter when it is consumed. Multiple unit rates may exist that correspond to varying volumes of usage i.e. a ‘block’ or ‘step’ tariff (first 50kWh @ X cents, next 50kWh at Y cents etc.</li><li>**SINGLE_RATE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**TIME_OF_USE** - energy usage is charged at unit rates that vary dependent on time of day and day of week that the energy is consumed</li><li>**TIME_OF_USE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**FLEXIBLE** - energy usage is charged at unit rates that vary based on external factors</li><li>**FLEXIBLE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**QUOTA** - all energy usage is charged at a single fixed rate, up to a specified usage quota/allowance. All excess usage beyond the allowance is then charged at a single unit rate (may not be the best way to explain it but it is essentially a ‘subscription’ or telco style product i.e. $50/month for up to 150kWh included usage</li></ul></value>
        [TypeConverter(typeof(CustomEnumConverter<PricingModelEnum>))]
        [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public enum PricingModelEnum
        {
            
            /// <summary>
            /// Enum SINGLERATEEnum for SINGLE_RATE
            /// </summary>
            [EnumMember(Value = "SINGLE_RATE")]
            SINGLERATEEnum = 1,
            
            /// <summary>
            /// Enum SINGLERATECONTLOADEnum for SINGLE_RATE_CONT_LOAD
            /// </summary>
            [EnumMember(Value = "SINGLE_RATE_CONT_LOAD")]
            SINGLERATECONTLOADEnum = 2,
            
            /// <summary>
            /// Enum TIMEOFUSEEnum for TIME_OF_USE
            /// </summary>
            [EnumMember(Value = "TIME_OF_USE")]
            TIMEOFUSEEnum = 3,
            
            /// <summary>
            /// Enum TIMEOFUSECONTLOADEnum for TIME_OF_USE_CONT_LOAD
            /// </summary>
            [EnumMember(Value = "TIME_OF_USE_CONT_LOAD")]
            TIMEOFUSECONTLOADEnum = 4,
            
            /// <summary>
            /// Enum FLEXIBLEEnum for FLEXIBLE
            /// </summary>
            [EnumMember(Value = "FLEXIBLE")]
            FLEXIBLEEnum = 5,
            
            /// <summary>
            /// Enum FLEXIBLECONTLOADEnum for FLEXIBLE_CONT_LOAD
            /// </summary>
            [EnumMember(Value = "FLEXIBLE_CONT_LOAD")]
            FLEXIBLECONTLOADEnum = 6,
            
            /// <summary>
            /// Enum QUOTAEnum for QUOTA
            /// </summary>
            [EnumMember(Value = "QUOTA")]
            QUOTAEnum = 7
        }

        /// <summary>
        /// The pricing model for the contract.  Contracts for gas must use SINGLE_RATE.  Note that the detail for the enumeration values are:&lt;ul&gt;&lt;li&gt;**SINGLE_RATE** - all energy usage is charged at a single unit rate no matter when it is consumed. Multiple unit rates may exist that correspond to varying volumes of usage i.e. a ‘block’ or ‘step’ tariff (first 50kWh @ X cents, next 50kWh at Y cents etc.&lt;/li&gt;&lt;li&gt;**SINGLE_RATE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.&lt;/li&gt;&lt;li&gt;**TIME_OF_USE** - energy usage is charged at unit rates that vary dependent on time of day and day of week that the energy is consumed&lt;/li&gt;&lt;li&gt;**TIME_OF_USE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.&lt;/li&gt;&lt;li&gt;**FLEXIBLE** - energy usage is charged at unit rates that vary based on external factors&lt;/li&gt;&lt;li&gt;**FLEXIBLE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.&lt;/li&gt;&lt;li&gt;**QUOTA** - all energy usage is charged at a single fixed rate, up to a specified usage quota/allowance. All excess usage beyond the allowance is then charged at a single unit rate (may not be the best way to explain it but it is essentially a ‘subscription’ or telco style product i.e. $50/month for up to 150kWh included usage&lt;/li&gt;&lt;/ul&gt;
        /// </summary>
        /// <value>The pricing model for the contract.  Contracts for gas must use SINGLE_RATE.  Note that the detail for the enumeration values are:&lt;ul&gt;&lt;li&gt;**SINGLE_RATE** - all energy usage is charged at a single unit rate no matter when it is consumed. Multiple unit rates may exist that correspond to varying volumes of usage i.e. a ‘block’ or ‘step’ tariff (first 50kWh @ X cents, next 50kWh at Y cents etc.&lt;/li&gt;&lt;li&gt;**SINGLE_RATE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.&lt;/li&gt;&lt;li&gt;**TIME_OF_USE** - energy usage is charged at unit rates that vary dependent on time of day and day of week that the energy is consumed&lt;/li&gt;&lt;li&gt;**TIME_OF_USE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.&lt;/li&gt;&lt;li&gt;**FLEXIBLE** - energy usage is charged at unit rates that vary based on external factors&lt;/li&gt;&lt;li&gt;**FLEXIBLE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.&lt;/li&gt;&lt;li&gt;**QUOTA** - all energy usage is charged at a single fixed rate, up to a specified usage quota/allowance. All excess usage beyond the allowance is then charged at a single unit rate (may not be the best way to explain it but it is essentially a ‘subscription’ or telco style product i.e. $50/month for up to 150kWh included usage&lt;/li&gt;&lt;/ul&gt;</value>
        [Required]
        [DataMember(Name="pricingModel", EmitDefaultValue=false)]
        public PricingModelEnum PricingModel { get; set; }


        /// <summary>
        /// Required if pricingModel is set to TIME_OF_USE.  Defines the time zone to use for calculation of the time of use thresholds
        /// </summary>
        /// <value>Required if pricingModel is set to TIME_OF_USE.  Defines the time zone to use for calculation of the time of use thresholds</value>
        [TypeConverter(typeof(CustomEnumConverter<TimeZoneEnum>))]
        [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public enum TimeZoneEnum
        {
            
            /// <summary>
            /// Enum LOCALEnum for LOCAL
            /// </summary>
            [EnumMember(Value = "LOCAL")]
            LOCALEnum = 1,
            
            /// <summary>
            /// Enum AESTEnum for AEST
            /// </summary>
            [EnumMember(Value = "AEST")]
            AESTEnum = 2
        }

        /// <summary>
        /// Required if pricingModel is set to TIME_OF_USE.  Defines the time zone to use for calculation of the time of use thresholds
        /// </summary>
        /// <value>Required if pricingModel is set to TIME_OF_USE.  Defines the time zone to use for calculation of the time of use thresholds</value>
        [DataMember(Name="timeZone", EmitDefaultValue=false)]
        public TimeZoneEnum TimeZone { get; set; }

        /// <summary>
        /// Flag indicating whether prices are fixed or variable
        /// </summary>
        /// <value>Flag indicating whether prices are fixed or variable</value>
        [Required]
        [DataMember(Name="isFixed", EmitDefaultValue=false)]
        public bool IsFixed { get; set; }

        /// <summary>
        /// Free text description of price variation policy and conditions for the contract.  Mandatory if isFixed is true
        /// </summary>
        /// <value>Free text description of price variation policy and conditions for the contract.  Mandatory if isFixed is true</value>
        [DataMember(Name="variation", EmitDefaultValue=false)]
        public string Variation { get; set; }

        /// <summary>
        /// Free text field that describes what will occur on or prior to expiry of the fixed contract term or benefit period
        /// </summary>
        /// <value>Free text field that describes what will occur on or prior to expiry of the fixed contract term or benefit period</value>
        [DataMember(Name="onExpiryDescription", EmitDefaultValue=false)]
        public string OnExpiryDescription { get; set; }


        /// <summary>
        /// Gets or Sets PaymentOption
        /// </summary>
        [TypeConverter(typeof(CustomEnumConverter<PaymentOptionEnum>))]
        [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public enum PaymentOptionEnum
        {
            
            /// <summary>
            /// Enum PAPERBILLEnum for PAPER_BILL
            /// </summary>
            [EnumMember(Value = "PAPER_BILL")]
            PAPERBILLEnum = 1,
            
            /// <summary>
            /// Enum CREDITCARDEnum for CREDIT_CARD
            /// </summary>
            [EnumMember(Value = "CREDIT_CARD")]
            CREDITCARDEnum = 2,
            
            /// <summary>
            /// Enum DIRECTDEBITEnum for DIRECT_DEBIT
            /// </summary>
            [EnumMember(Value = "DIRECT_DEBIT")]
            DIRECTDEBITEnum = 3,
            
            /// <summary>
            /// Enum BPAYEnum for BPAY
            /// </summary>
            [EnumMember(Value = "BPAY")]
            BPAYEnum = 4,
            
            /// <summary>
            /// Enum OTHEREnum for OTHER
            /// </summary>
            [EnumMember(Value = "OTHER")]
            OTHEREnum = 5
        }


        /// <summary>
        /// Payment options for this contract
        /// </summary>
        /// <value>Payment options for this contract</value>
        [TypeConverter(typeof(CustomEnumConverter<List&lt;PaymentOptionEnum&gt;>))]
        [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public enum List&lt;PaymentOptionEnum&gt;
        {
            
            /// <summary>
            /// Enum PAPERBILLEnum for PAPER_BILL
            /// </summary>
            [EnumMember(Value = "PAPER_BILL")]
            PAPERBILLEnum = 1,
            
            /// <summary>
            /// Enum CREDITCARDEnum for CREDIT_CARD
            /// </summary>
            [EnumMember(Value = "CREDIT_CARD")]
            CREDITCARDEnum = 2,
            
            /// <summary>
            /// Enum DIRECTDEBITEnum for DIRECT_DEBIT
            /// </summary>
            [EnumMember(Value = "DIRECT_DEBIT")]
            DIRECTDEBITEnum = 3,
            
            /// <summary>
            /// Enum BPAYEnum for BPAY
            /// </summary>
            [EnumMember(Value = "BPAY")]
            BPAYEnum = 4,
            
            /// <summary>
            /// Enum OTHEREnum for OTHER
            /// </summary>
            [EnumMember(Value = "OTHER")]
            OTHEREnum = 5
        }

        /// <summary>
        /// Payment options for this contract
        /// </summary>
        /// <value>Payment options for this contract</value>
        [Required]
        [DataMember(Name="paymentOption", EmitDefaultValue=false)]
        public List<PaymentOptionEnum> PaymentOption { get; set; }

        /// <summary>
        /// Gets or Sets IntrinsicGreenPower
        /// </summary>
        [DataMember(Name="intrinsicGreenPower", EmitDefaultValue=false)]
        public EnergyPlanContractIntrinsicGreenPower IntrinsicGreenPower { get; set; }

        /// <summary>
        /// Gets or Sets ControlledLoad
        /// </summary>
        [DataMember(Name="controlledLoad", EmitDefaultValue=false)]
        public EnergyPlanControlledLoad ControlledLoad { get; set; }

        /// <summary>
        /// Optional list of incentives available for the contract
        /// </summary>
        /// <value>Optional list of incentives available for the contract</value>
        [DataMember(Name="incentives", EmitDefaultValue=false)]
        public List<Object> Incentives { get; set; }

        /// <summary>
        /// Optional list of discounts available for the contract
        /// </summary>
        /// <value>Optional list of discounts available for the contract</value>
        [DataMember(Name="discounts", EmitDefaultValue=false)]
        public List<Object> Discounts { get; set; }

        /// <summary>
        /// Optional list of charges applicable to green power
        /// </summary>
        /// <value>Optional list of charges applicable to green power</value>
        [DataMember(Name="greenPowerCharges", EmitDefaultValue=false)]
        public List<Object> GreenPowerCharges { get; set; }

        /// <summary>
        /// Eligibility restrictions or requirements
        /// </summary>
        /// <value>Eligibility restrictions or requirements</value>
        [DataMember(Name="eligibility", EmitDefaultValue=false)]
        public List<Object> Eligibility { get; set; }

        /// <summary>
        /// An array of fees applicable to the plan
        /// </summary>
        /// <value>An array of fees applicable to the plan</value>
        [DataMember(Name="fees", EmitDefaultValue=false)]
        public List<Object> Fees { get; set; }

        /// <summary>
        /// Array of feed in tariffs for solar power
        /// </summary>
        /// <value>Array of feed in tariffs for solar power</value>
        [DataMember(Name="solarFeedInTariff", EmitDefaultValue=false)]
        public List<Object> SolarFeedInTariff { get; set; }

        /// <summary>
        /// Array of tariff periods
        /// </summary>
        /// <value>Array of tariff periods</value>
        [Required]
        [DataMember(Name="tariffPeriod", EmitDefaultValue=false)]
        public List<Object> TariffPeriod { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class EnergyPlanContract {\n");
            sb.Append("  AdditionalFeeInformation: ").Append(AdditionalFeeInformation).Append("\n");
            sb.Append("  PricingModel: ").Append(PricingModel).Append("\n");
            sb.Append("  TimeZone: ").Append(TimeZone).Append("\n");
            sb.Append("  IsFixed: ").Append(IsFixed).Append("\n");
            sb.Append("  Variation: ").Append(Variation).Append("\n");
            sb.Append("  OnExpiryDescription: ").Append(OnExpiryDescription).Append("\n");
            sb.Append("  PaymentOption: ").Append(PaymentOption).Append("\n");
            sb.Append("  IntrinsicGreenPower: ").Append(IntrinsicGreenPower).Append("\n");
            sb.Append("  ControlledLoad: ").Append(ControlledLoad).Append("\n");
            sb.Append("  Incentives: ").Append(Incentives).Append("\n");
            sb.Append("  Discounts: ").Append(Discounts).Append("\n");
            sb.Append("  GreenPowerCharges: ").Append(GreenPowerCharges).Append("\n");
            sb.Append("  Eligibility: ").Append(Eligibility).Append("\n");
            sb.Append("  Fees: ").Append(Fees).Append("\n");
            sb.Append("  SolarFeedInTariff: ").Append(SolarFeedInTariff).Append("\n");
            sb.Append("  TariffPeriod: ").Append(TariffPeriod).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (obj is null) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((EnergyPlanContract)obj);
        }

        /// <summary>
        /// Returns true if EnergyPlanContract instances are equal
        /// </summary>
        /// <param name="other">Instance of EnergyPlanContract to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(EnergyPlanContract other)
        {
            if (other is null) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    AdditionalFeeInformation == other.AdditionalFeeInformation ||
                    AdditionalFeeInformation != null &&
                    AdditionalFeeInformation.Equals(other.AdditionalFeeInformation)
                ) && 
                (
                    PricingModel == other.PricingModel ||
                    
                    PricingModel.Equals(other.PricingModel)
                ) && 
                (
                    TimeZone == other.TimeZone ||
                    
                    TimeZone.Equals(other.TimeZone)
                ) && 
                (
                    IsFixed == other.IsFixed ||
                    
                    IsFixed.Equals(other.IsFixed)
                ) && 
                (
                    Variation == other.Variation ||
                    Variation != null &&
                    Variation.Equals(other.Variation)
                ) && 
                (
                    OnExpiryDescription == other.OnExpiryDescription ||
                    OnExpiryDescription != null &&
                    OnExpiryDescription.Equals(other.OnExpiryDescription)
                ) && 
                (
                    PaymentOption == other.PaymentOption ||
                    PaymentOption.SequenceEqual(other.PaymentOption)
                ) && 
                (
                    IntrinsicGreenPower == other.IntrinsicGreenPower ||
                    IntrinsicGreenPower != null &&
                    IntrinsicGreenPower.Equals(other.IntrinsicGreenPower)
                ) && 
                (
                    ControlledLoad == other.ControlledLoad ||
                    ControlledLoad != null &&
                    ControlledLoad.Equals(other.ControlledLoad)
                ) && 
                (
                    Incentives == other.Incentives ||
                    Incentives != null &&
                    other.Incentives != null &&
                    Incentives.SequenceEqual(other.Incentives)
                ) && 
                (
                    Discounts == other.Discounts ||
                    Discounts != null &&
                    other.Discounts != null &&
                    Discounts.SequenceEqual(other.Discounts)
                ) && 
                (
                    GreenPowerCharges == other.GreenPowerCharges ||
                    GreenPowerCharges != null &&
                    other.GreenPowerCharges != null &&
                    GreenPowerCharges.SequenceEqual(other.GreenPowerCharges)
                ) && 
                (
                    Eligibility == other.Eligibility ||
                    Eligibility != null &&
                    other.Eligibility != null &&
                    Eligibility.SequenceEqual(other.Eligibility)
                ) && 
                (
                    Fees == other.Fees ||
                    Fees != null &&
                    other.Fees != null &&
                    Fees.SequenceEqual(other.Fees)
                ) && 
                (
                    SolarFeedInTariff == other.SolarFeedInTariff ||
                    SolarFeedInTariff != null &&
                    other.SolarFeedInTariff != null &&
                    SolarFeedInTariff.SequenceEqual(other.SolarFeedInTariff)
                ) && 
                (
                    TariffPeriod == other.TariffPeriod ||
                    TariffPeriod != null &&
                    other.TariffPeriod != null &&
                    TariffPeriod.SequenceEqual(other.TariffPeriod)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (AdditionalFeeInformation != null)
                    hashCode = hashCode * 59 + AdditionalFeeInformation.GetHashCode();
                    
                    hashCode = hashCode * 59 + PricingModel.GetHashCode();
                    
                    hashCode = hashCode * 59 + TimeZone.GetHashCode();
                    
                    hashCode = hashCode * 59 + IsFixed.GetHashCode();
                    if (Variation != null)
                    hashCode = hashCode * 59 + Variation.GetHashCode();
                    if (OnExpiryDescription != null)
                    hashCode = hashCode * 59 + OnExpiryDescription.GetHashCode();
                    
                    hashCode = hashCode * 59 + PaymentOption.GetHashCode();
                    if (IntrinsicGreenPower != null)
                    hashCode = hashCode * 59 + IntrinsicGreenPower.GetHashCode();
                    if (ControlledLoad != null)
                    hashCode = hashCode * 59 + ControlledLoad.GetHashCode();
                    if (Incentives != null)
                    hashCode = hashCode * 59 + Incentives.GetHashCode();
                    if (Discounts != null)
                    hashCode = hashCode * 59 + Discounts.GetHashCode();
                    if (GreenPowerCharges != null)
                    hashCode = hashCode * 59 + GreenPowerCharges.GetHashCode();
                    if (Eligibility != null)
                    hashCode = hashCode * 59 + Eligibility.GetHashCode();
                    if (Fees != null)
                    hashCode = hashCode * 59 + Fees.GetHashCode();
                    if (SolarFeedInTariff != null)
                    hashCode = hashCode * 59 + SolarFeedInTariff.GetHashCode();
                    if (TariffPeriod != null)
                    hashCode = hashCode * 59 + TariffPeriod.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(EnergyPlanContract left, EnergyPlanContract right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(EnergyPlanContract left, EnergyPlanContract right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
